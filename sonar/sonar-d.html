<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="css/main.css">
    <style type="text/css">
      #viz-major{
        height: 450px;
        margin-top: -5px;
      }
      #viz-minor{
        height: 250px;
      }
    </style>
  </head>
  <body>

    <div id="viz_container">
      <div id="viz-minor" class="viz-minor"></div>
      <div id="viz-major" class="viz-major"></div>
      <div id="legend"></div>
      
      <input id="data_updation_interval" type="text" value="1000">
      <button id="btn_data_updation_interval">Update</button>
      
    </div>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.4.3/d3.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="js/d3.sonar.js"></script>

    <script type="text/javascript">

      var sonar_major_el = document.querySelector("#viz-major");
      var sonar_minor_el = document.querySelector("#viz-minor");

      var PAST_TIME_JAR = 30 * 60 * 1000; // 19 minutes in milliseconds
      var LIVE_TIME_JAR = 1 * 60 * 1000; // 1 minute in milliseconds

      var past_time_jar_set = [];

      var dataset_keys = d3.set([]);

      var UPDATE_STEP = 2000; // 2 seconds

      var active_timers = [],
        data_updation_interval = 50;  // in milliseconds

      var FIRST_RUN_TIME;

      var colors = {
            indicator: "#aace00",
            heading: "#1A68DB"
          }

      function x_special_case(d) {
        return (d <= 180) ? ((d+180) === 360 ? 0: (d+180)) : d-180;
      }
      function x_special_case_inverse(d) {
        var _d = (d <= 180) ? d+180 : d-180;
        return _d;
      }

      // Minor Viz
      var sonar_minor_viz = d3.sonar()
                        .container_el(sonar_minor_el)/*
                        .xTickValues([0,45,90,135,180,225,270,315,360])
                        .xTickFormat(
                          function (d) {
                            return (d <= 180) ? ((d+180) === 360 ? 0: (d+180)) : d-180;
                          }
                        )
                        .xTickFormatInverse(
                          function (d) {
                            return (d <= 180) ? d+180 : d-180;
                          }
                        )*/
                        .yTicks(4)
                        .headingKeys({
                          x: 'degree',
                          y: 'date'
                        })
                        .detectionKeys({
                          x: 'degree',
                          y: 'date'
                        })
                        .margin({top: 40, left: 100, bottom: 5, right: 50})
                        .dataAge(LIVE_TIME_JAR)
                        .colors(colors)
                        .yAxisLabel("");

      // Major Viz
      var sonar_major_viz = d3.sonar()
                        .container_el(sonar_major_el)/*
                        .xTickValues([0,45,90,135,180,225,270,315,360])
                        .xTickFormat(
                          function (d) {
                            return (d <= 180) ? ((d+180) === 360 ? 0: (d+180)) : d-180;
                          }
                        )
                        .xTickFormatInverse(
                          function (d) {
                            return (d <= 180) ? d+180 : d-180;
                          }
                        )*/
                        .yTicks(8)
                        .headingKeys({
                          x: 'degree',
                          y: 'date'
                        })
                        .showXAxis(false)
                        .margin({top: 0, left: 100, bottom: 50, right: 50})
                        .detectionKeys({
                          x: 'degree',
                          y: 'date'
                        })
                        .dataAge(PAST_TIME_JAR)
                        .colors(colors);

      // Returns a random integer between min and max
      // Using Math.round() will give you a non-uniform distribution!
      function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function _t_step(n) {
        return new Date( _t_step_init + n*UPDATE_STEP );
      }
      
      var _t_step_init;

      function setDataUpdateRoutine(reset) {
        _t_step_init = new Date().getTime();

        if (reset) {
          FIRST_RUN_TIME = _t_step_init;
        };

        var i = 0, j = 0, k = 0, l = 0;
        active_timers.push( 
          setInterval(function(){
            addHeading( _t_step(++i), getRandomInt(110,150) );
          }, data_updation_interval )
        );

        active_timers.push( 
          setInterval(function(){
            addDetection(_t_step(++j), 'New Delhi', getRandomInt(110,120), getRandomInt(1,10)  );
          }, data_updation_interval )
        );

        active_timers.push(
          setInterval(function(){
            addDetection(_t_step(++k), 'Bangalore', getRandomInt(140,150), getRandomInt(1,10)  );
          }, data_updation_interval)
        );

        active_timers.push( 
          setInterval(function(){
            addDetection(_t_step(++l), 'Vadodara', getRandomInt(130,140), getRandomInt(1,10)  );
          }, data_updation_interval)
        );

        active_timers.push( 
          setInterval( add_data_to_major_viz, data_updation_interval)
        );

      }

      function addHeading(time, bearing) {
    
        var data = {
            name: 'Heading',
            time: new Date(time),
            value: bearing,
            is_heading: true
        }

        // add to dataset
        past_time_jar_set.push(data);

        sonar_minor_viz
          .purgeOldData(true)
          .addHeading(data);
      }

      function addDetection(time, seriesName, bearing, strength){
        
        var data = {
            name: seriesName,
            time: new Date(time),
            value: bearing,
            strength: strength,
            is_detection: true
        }

        // add to dataset
        past_time_jar_set.push(data);

        sonar_minor_viz
          .purgeOldData(true)
          .addDetection(data);
      }
      
      function add_data_to_major_viz(){
          var latest = d3.max( past_time_jar_set, function(d){ return d.time; });

          // data points which need to go to past data viz
          var push_past_time_jar_set = past_time_jar_set.filter(function(d){ 
            return ( ( new Date(latest).getTime() - new Date(d.time).getTime() ) >= LIVE_TIME_JAR );
          });
          
          past_time_jar_set = past_time_jar_set.filter(function(d){ 
            return ( ( new Date(latest).getTime() - new Date(d.time).getTime() ) < LIVE_TIME_JAR );
          });

          push_past_time_jar_set.forEach(function(d,i){
            
            if ( d.is_heading ) {
              sonar_major_viz
                .purgeOldData(true)
                .addHeading(d);
            }else{
              sonar_major_viz
                .purgeOldData(true)
                .addDetection(d);
            };

          });
      }

      $("#btn_data_updation_interval").on("click", function(e){
        // clear interval
        active_timers.forEach(function(t){
          clearInterval(t);
        });
        active_timers = [];
        data_updation_interval = +$("#data_updation_interval").val();
        setDataUpdateRoutine(true);
      });

      // begin
      sonar_major_viz();
      sonar_minor_viz();
      // update dataset
      setDataUpdateRoutine(true);

      $(window).resize(function(e){
        resize();
      });

      function resize() {
         // make sure major viz is 75% of total height and minor viz is 25%
        var h = $(window).height();
        
        $("#viz-minor").height( Math.floor(h*0.25) );
        $("#viz-major").height( Math.floor(h*0.75) );
      }

      resize();

    </script>

  </body>
</html>